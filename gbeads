#!/usr/bin/env bash
# gbeads - GitHub issue wrapper for work organization
#
# A lightweight CLI that wraps `gh` to provide work organization
# primitives using GitHub issues with type labels and metadata blocks.

set -euo pipefail

readonly VERSION="0.1.0"

# Valid issue types
readonly VALID_TYPES=("feature" "story" "task" "bug")

# Type to label mapping
declare -A TYPE_LABELS=(
  ["feature"]="type: feature"
  ["story"]="type: user story"
  ["task"]="type: task"
  ["bug"]="type: bug"
)

# Get the GitHub repo in owner/repo format from git remote
get_repo() {
  local remote_url
  remote_url=$(git remote get-url origin 2>/dev/null) || {
    echo ""
    return 1
  }

  # Handle SSH format: git@github.com:owner/repo.git
  if [[ "$remote_url" =~ git@github\.com:([^/]+)/(.+)(\.git)?$ ]]; then
    echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    return 0
  fi

  # Handle HTTPS format: https://github.com/owner/repo.git
  if [[ "$remote_url" =~ https://github\.com/([^/]+)/(.+)(\.git)?$ ]]; then
    echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    return 0
  fi

  echo ""
  return 1
}

# Require that we're in a git repo with a GitHub remote
# Sets REPO variable on success, exits on failure
require_repo() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "Error: Not in a git repository" >&2
    exit 1
  fi

  REPO=$(get_repo)
  if [[ -z "$REPO" ]]; then
    echo "Error: Could not determine GitHub repository from git remote" >&2
    echo "Make sure 'origin' points to a GitHub repository." >&2
    exit 1
  fi

  export REPO
}

# Validate issue type
# Usage: validate_type "type"
validate_type() {
  local type="$1"
  for valid in "${VALID_TYPES[@]}"; do
    if [[ "$type" == "$valid" ]]; then
      return 0
    fi
  done
  echo "Error: Invalid type '$type'" >&2
  echo "Valid types: ${VALID_TYPES[*]}" >&2
  return 1
}

# Get label for type
# Usage: get_type_label "type"
get_type_label() {
  local type="$1"
  echo "${TYPE_LABELS[$type]}"
}

# Create initial metadata block
# Usage: create_metadata [parent]
create_metadata() {
  local parent="${1:-null}"
  cat <<EOF
<details>
<summary>Metadata</summary>

| Field | Value |
|-------|-------|
| depends_on | [] |
| claimed_by | null |
| parent | $parent |

</details>
EOF
}

# Parse metadata from issue body, returns the value of a field
# Usage: parse_metadata_field "body" "field_name"
parse_metadata_field() {
  local body="$1"
  local field="$2"

  # Use Python for reliable HTML table parsing (stdin avoids quoting issues)
  echo "$body" | python3 -c "
import sys
import re

body = sys.stdin.read()
field = sys.argv[1]

# Check if body has metadata block
if not body.startswith('<details>'):
    print('')
    sys.exit(0)

# Find the table rows
# Pattern: | field_name | value |
pattern = rf'\| {re.escape(field)} \| (.+?) \|'
match = re.search(pattern, body)
if match:
    print(match.group(1).strip())
else:
    print('')
" "$field"
}

# Update a field in the metadata, returns the complete updated body
# Usage: update_metadata_field "body" "field_name" "new_value"
update_metadata_field() {
  local body="$1"
  local field="$2"
  local value="$3"

  # Use Python for reliable HTML table manipulation (stdin avoids quoting issues)
  echo "$body" | python3 -c "
import sys
import re

body = sys.stdin.read()
field = sys.argv[1]
value = sys.argv[2]

# If no metadata exists, create it
if not body.startswith('<details>'):
    # Generate metadata block
    metadata = '''<details>
<summary>Metadata</summary>

| Field | Value |
|-------|-------|
| depends_on | [] |
| claimed_by | null |
| parent | null |

</details>'''
    body = metadata + '\n' + body if body else metadata

# Replace the field value in the table
# Pattern matches: | field_name | old_value |
pattern = rf'(\| {re.escape(field)} \|) .+? \|'
replacement = rf'\g<1> {value} |'
body = re.sub(pattern, replacement, body)

print(body)
" "$field" "$value"
}

# Extract body content after metadata block (before ## Tasks if present)
# Usage: get_body_content "full_body"
get_body_content() {
  local body="$1"

  # Use Python for reliable parsing (stdin avoids quoting issues)
  echo "$body" | python3 -c "
import sys

body = sys.stdin.read()

# If no metadata block, return as-is
if not body.startswith('<details>'):
    print(body)
    sys.exit(0)

# Find end of metadata block (</details>)
end_marker = '</details>'
end_pos = body.find(end_marker)
if end_pos == -1:
    print(body)
    sys.exit(0)

# Extract content after </details>
content = body[end_pos + len(end_marker):].strip()

# If there's a ## Tasks section, only return content before it
tasks_marker = '## Tasks'
tasks_pos = content.find(tasks_marker)
if tasks_pos != -1:
    content = content[:tasks_pos].strip()

print(content)
"
}

# Check if issue body has a task list section
# Usage: has_task_list "body"
has_task_list() {
  local body="$1"
  [[ "$body" =~ "## Tasks" ]]
}

# Add a child to the task list in the body
# Usage: add_task_list_entry "body" "number" "title"
add_task_list_entry() {
  local body="$1"
  local number="$2"
  local title="$3"

  local entry="- [ ] #${number} ${title}"

  if has_task_list "$body"; then
    # Add after ## Tasks heading (POSIX-compatible approach)
    # Note: BSD sed (macOS) and GNU sed have different 'a' command syntax
    # Using awk for cross-platform compatibility
    echo "$body" | awk -v entry="$entry" '/^## Tasks$/{print; print entry; next}1'
  else
    # Add new ## Tasks section at end
    echo "$body"
    echo ""
    echo "## Tasks"
    echo "$entry"
  fi
}

# Remove a child from the task list
# Usage: remove_task_list_entry "body" "number"
remove_task_list_entry() {
  local body="$1"
  local number="$2"

  # Remove line matching "- [ ] #N " or "- [x] #N "
  # Using '|| true' to handle case where all lines are removed (grep -v returns 1)
  echo "$body" | { grep -v "^- \[[ x]\] #${number} " || true; }
}

# Update title in task list entry
# Usage: update_task_list_title "body" "number" "new_title"
update_task_list_title() {
  local body="$1"
  local number="$2"
  local new_title="$3"

  # Replace the title part after #N
  # shellcheck disable=SC2001
  echo "$body" | sed "s/^\(- \[[ x]\] #${number}\) .*/\1 ${new_title}/"
}

# Parse task list entries from body
# Usage: parse_task_list "body"
# Output: "number|title|checked" per line
parse_task_list() {
  local body="$1"

  echo "$body" | { grep "^- \[[ x]\] #[0-9]" || true; } | while read -r line; do
    local checked="false"
    # shellcheck disable=SC2076
    if [[ "$line" =~ "- [x]" ]]; then
      checked="true"
    fi
    local number
    # shellcheck disable=SC2001
    number=$(echo "$line" | sed 's/^- \[[ x]\] #\([0-9]*\).*/\1/')
    local title
    # shellcheck disable=SC2001
    title=$(echo "$line" | sed 's/^- \[[ x]\] #[0-9]* //')
    echo "${number}|${title}|${checked}"
  done
}

# List issues with optional filters
# Usage: gbeads list [--type <type>] [--claimed-by <id>] [--unclaimed] [--state <state>]
cmd_list() {
  require_repo

  local filter_type=""
  local filter_claimed_by=""
  local filter_unclaimed=false
  local filter_state="open"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type)
        filter_type="$2"
        if ! validate_type "$filter_type"; then
          exit 1
        fi
        shift 2
        ;;
      --claimed-by)
        filter_claimed_by="$2"
        shift 2
        ;;
      --unclaimed)
        filter_unclaimed=true
        shift
        ;;
      --state)
        filter_state="$2"
        shift 2
        ;;
      --all)
        filter_state="all"
        shift
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Build label filter
  local label_filter=""
  if [[ -n "$filter_type" ]]; then
    label_filter=$(get_type_label "$filter_type")
  fi

  # Get issues as JSON
  local issues_json
  if [[ -n "$label_filter" ]]; then
    issues_json=$(gh issue list --repo "$REPO" --state "$filter_state" --label "$label_filter" --json number,title,state,body,labels --limit 100)
  else
    issues_json=$(gh issue list --repo "$REPO" --state "$filter_state" --json number,title,state,body,labels --limit 100)
  fi

  # Check if we have any issues
  if [[ -z "$issues_json" ]] || [[ "$issues_json" == "[]" ]]; then
    echo "No issues found."
    return 0
  fi

  # Header
  printf "%-6s %-8s %-12s %s\n" "ID" "TYPE" "CLAIMED" "TITLE"
  printf "%-6s %-8s %-12s %s\n" "------" "--------" "------------" "-----"

  # Parse JSON and display using Python for reliable JSON handling
  # shellcheck disable=SC2016
  echo "$issues_json" | python3 -c "
import json
import sys

data = json.load(sys.stdin)
for issue in data:
    number = issue['number']
    title = issue['title']
    body = issue.get('body', '')
    labels = [l['name'] for l in issue.get('labels', [])]

    # Determine type
    issue_type = 'unknown'
    type_map = {
        'type: feature': 'feature',
        'type: user story': 'story',
        'type: task': 'task',
        'type: bug': 'bug'
    }
    for label in labels:
        if label in type_map:
            issue_type = type_map[label]
            break

    # Parse claimed_by from metadata table
    claimed_by = '-'
    if body.startswith('<details>'):
        import re
        match = re.search(r'\| claimed_by \| (.+?) \|', body)
        if match:
            val = match.group(1).strip()
            if val and val != 'null':
                claimed_by = val

    # Apply filters
    filter_claimed = '${filter_claimed_by}'
    filter_unclaimed = '${filter_unclaimed}'

    if filter_claimed and claimed_by != filter_claimed:
        continue
    if filter_unclaimed == 'true' and claimed_by != '-':
        continue

    print(f'#{number:<5} {issue_type:<8} {claimed_by:<12} {title}')
"
}

# List available work (unclaimed + unblocked)
# Usage: gbeads ready
cmd_ready() {
  require_repo

  # Get all issues (open and closed) to check dependency states
  local issues_json
  issues_json=$(gh issue list --repo "$REPO" --state all --json number,title,state,body,labels --limit 500)

  # Check if we have any issues
  if [[ -z "$issues_json" ]] || [[ "$issues_json" == "[]" ]]; then
    echo "No available work."
    return 0
  fi

  # Use Python to filter to unclaimed, unblocked, open issues
  # shellcheck disable=SC2016
  local result
  result=$(echo "$issues_json" | python3 -c '
import json
import sys
import re

data = json.load(sys.stdin)

# Build map of issue number -> state (normalize to uppercase)
issue_states = {}
for issue in data:
    issue_states[issue["number"]] = issue["state"].upper()

# Filter for available work
available = []
for issue in data:
    # Skip if not open (handle both uppercase and lowercase)
    if issue["state"].upper() != "OPEN":
        continue

    body = issue.get("body", "")
    labels = [l["name"] for l in issue.get("labels", [])]

    # Parse claimed_by from metadata
    claimed_by = None
    if body.startswith("<details>"):
        match = re.search(r"\| claimed_by \| (.+?) \|", body)
        if match:
            val = match.group(1).strip()
            if val and val != "null":
                claimed_by = val

    # Skip if claimed
    if claimed_by:
        continue

    # Parse depends_on from metadata
    depends_on = []
    if body.startswith("<details>"):
        match = re.search(r"\| depends_on \| (.+?) \|", body)
        if match:
            val = match.group(1).strip()
            try:
                deps = json.loads(val)
                if isinstance(deps, list):
                    depends_on = deps
            except:
                pass

    # Check if all dependencies are closed
    blocked = False
    for dep in depends_on:
        dep_state = issue_states.get(dep)
        # If dependency is not closed (or not found), issue is blocked
        if dep_state != "CLOSED":
            blocked = True
            break

    if blocked:
        continue

    # Determine type
    issue_type = "unknown"
    type_map = {
        "type: feature": "feature",
        "type: user story": "story",
        "type: task": "task",
        "type: bug": "bug"
    }
    for label in labels:
        if label in type_map:
            issue_type = type_map[label]
            break

    available.append({
        "number": issue["number"],
        "title": issue["title"],
        "type": issue_type
    })

if not available:
    print("NO_AVAILABLE_WORK")
else:
    print("HEADER")
    for a in available:
        num = a["number"]
        typ = a["type"]
        title = a["title"]
        print(f"#{num:<5} {typ:<8} {title}")
')

  if [[ "$result" == "NO_AVAILABLE_WORK" ]]; then
    echo "No available work."
    return 0
  fi

  # Print header and results
  printf "%-6s %-8s %s\n" "ID" "TYPE" "TITLE"
  printf "%-6s %-8s %s\n" "------" "--------" "-----"
  echo "$result" | tail -n +2 # Skip HEADER marker
}

# Show issue details
# Usage: gbeads show <number>
cmd_show() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads show <number>" >&2
    exit 1
  fi

  local number="$1"

  # Get issue data
  local issue_json
  issue_json=$(gh issue view "$number" --repo "$REPO" --json number,title,state,body,labels 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Parse and display using Python for reliable JSON handling
  # shellcheck disable=SC2016
  echo "$issue_json" | python3 -c "
import json
import sys

issue = json.load(sys.stdin)
number = issue['number']
title = issue['title']
state = issue['state']
body = issue.get('body', '')
labels = [l['name'] for l in issue.get('labels', [])]

# Determine type
issue_type = 'unknown'
type_map = {
    'type: feature': 'feature',
    'type: user story': 'story',
    'type: task': 'task',
    'type: bug': 'bug'
}
for label in labels:
    if label in type_map:
        issue_type = type_map[label]
        break

# Parse metadata
import re
depends_on = '[]'
claimed_by = 'null'
parent = 'null'
body_content = body

if body.startswith('<details>'):
    # Find end of metadata block (</details>)
    end_marker = '</details>'
    end_pos = body.find(end_marker)
    if end_pos > 0:
        metadata_section = body[:end_pos + len(end_marker)]

        # Extract values from metadata table
        depends_on_match = re.search(r'\| depends_on \| (.+?) \|', metadata_section)
        if depends_on_match:
            depends_on = depends_on_match.group(1).strip()

        claimed_by_match = re.search(r'\| claimed_by \| (.+?) \|', metadata_section)
        if claimed_by_match:
            claimed_by = claimed_by_match.group(1).strip()

        parent_match = re.search(r'\| parent \| (.+?) \|', metadata_section)
        if parent_match:
            parent = parent_match.group(1).strip()

        # Extract body content after </details>
        content = body[end_pos + len(end_marker):].strip()

        # Remove ## Tasks section if present
        tasks_pos = content.find('## Tasks')
        if tasks_pos != -1:
            content = content[:tasks_pos].strip()

        body_content = content

print(f'Issue #{number}: {title}')
print(f'Type:       {issue_type}')
print(f'State:      {state}')
print(f'Claimed by: {claimed_by}')
print(f'Parent:     {parent}')
print(f'Depends on: {depends_on}')
if body_content:
    print()
    print('Description:')
    print(body_content)
"
}

# Initialize gbeads labels in the repository
cmd_init() {
  require_repo

  echo "Initializing gbeads labels in $REPO..."

  local created=0
  local exists=0

  for type in "${VALID_TYPES[@]}"; do
    local label="${TYPE_LABELS[$type]}"
    if gh label create "$label" --repo "$REPO" --description "gbeads: $type" 2>/dev/null; then
      echo "  Created: $label"
      created=$((created + 1))
    else
      echo "  Exists: $label"
      exists=$((exists + 1))
    fi
  done

  echo "Done. Created $created labels, $exists already existed."
}

# Create a new issue
# Usage: gbeads create <type> "title" [--parent <n>] [--body "description"]
cmd_create() {
  require_repo

  if [[ $# -lt 2 ]]; then
    echo "Usage: gbeads create <type> \"title\" [--parent <n>] [--body \"description\"]" >&2
    exit 1
  fi

  local type="$1"
  local title="$2"
  shift 2

  # Validate type
  if ! validate_type "$type"; then
    exit 1
  fi

  # Parse optional flags
  local parent=""
  local body_content=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parent)
        parent="$2"
        shift 2
        ;;
      --body)
        body_content="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Create metadata
  local body
  if [[ -n "$parent" ]]; then
    body=$(create_metadata "$parent")
  else
    body=$(create_metadata)
  fi

  # Append user body content if provided
  if [[ -n "$body_content" ]]; then
    body="${body}"$'\n\n'"${body_content}"
  fi

  # Get the label for this type
  local label
  label=$(get_type_label "$type")

  # Create the issue
  local output
  output=$(gh issue create --repo "$REPO" --title "$title" --body "$body" --label "$label")

  # Extract issue number from output URL
  local number
  number=$(echo "$output" | grep -o '[0-9]*$')

  echo "Created $type #$number: $title"

  # If parent specified, update parent's task list
  if [[ -n "$parent" ]]; then
    local parent_body
    parent_body=$(gh issue view "$parent" --repo "$REPO" --json body --jq '.body')

    local updated_body
    updated_body=$(add_task_list_entry "$parent_body" "$number" "$title")

    gh issue edit "$parent" --repo "$REPO" --body "$updated_body"
    echo "Added to parent #$parent task list"
  fi
}

# Claim an issue for a worker
# Usage: gbeads claim <number> <worker-id>
cmd_claim() {
  require_repo

  if [[ $# -lt 2 ]]; then
    echo "Usage: gbeads claim <number> <worker-id>" >&2
    exit 1
  fi

  local number="$1"
  local worker_id="$2"

  # Get current issue body
  local body
  body=$(gh issue view "$number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Check if already claimed
  local current_claimed
  current_claimed=$(parse_metadata_field "$body" "claimed_by")
  if [[ -n "$current_claimed" && "$current_claimed" != "null" ]]; then
    echo "Error: Issue #$number is already claimed by $current_claimed" >&2
    exit 1
  fi

  # Update claimed_by in metadata
  local updated_body
  updated_body=$(update_metadata_field "$body" "claimed_by" "$worker_id")

  # Save updated body
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"

  echo "Claimed issue #$number for $worker_id"
}

# Release a claimed issue
# Usage: gbeads unclaim <number>
cmd_unclaim() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads unclaim <number>" >&2
    exit 1
  fi

  local number="$1"

  # Get current issue body
  local body
  body=$(gh issue view "$number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Check if actually claimed
  local current_claimed
  current_claimed=$(parse_metadata_field "$body" "claimed_by")
  if [[ -z "$current_claimed" || "$current_claimed" == "null" ]]; then
    echo "Issue #$number is not claimed" >&2
    exit 0
  fi

  # Update claimed_by to null
  local updated_body
  updated_body=$(update_metadata_field "$body" "claimed_by" "null")

  # Save updated body
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"

  echo "Released claim on issue #$number (was: $current_claimed)"
}

# Close an issue
# Usage: gbeads close <number>
cmd_close() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads close <number>" >&2
    exit 1
  fi

  local number="$1"

  gh issue close "$number" --repo "$REPO" || {
    echo "Error: Failed to close issue #$number" >&2
    exit 1
  }

  echo "Closed issue #$number"
}

# Reopen a closed issue
# Usage: gbeads reopen <number>
cmd_reopen() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads reopen <number>" >&2
    exit 1
  fi

  local number="$1"

  gh issue reopen "$number" --repo "$REPO" || {
    echo "Error: Failed to reopen issue #$number" >&2
    exit 1
  }

  echo "Reopened issue #$number"
}

# Update an issue
# Usage: gbeads update <number> [--title "new title"] [--type <type>] [--body "description"]
cmd_update() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads update <number> [--title \"new title\"] [--type <type>] [--body \"description\"]" >&2
    exit 1
  fi

  local number="$1"
  shift

  local new_title=""
  local new_type=""
  local new_body=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        new_title="$2"
        shift 2
        ;;
      --type)
        new_type="$2"
        if ! validate_type "$new_type"; then
          exit 1
        fi
        shift 2
        ;;
      --body)
        new_body="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  if [[ -z "$new_title" && -z "$new_type" && -z "$new_body" ]]; then
    echo "Error: Must specify --title, --type, or --body" >&2
    exit 1
  fi

  # Get current issue data
  local issue_json
  issue_json=$(gh issue view "$number" --repo "$REPO" --json title,body,labels 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  local current_body current_labels
  current_body=$(echo "$issue_json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('body',''))")
  current_labels=$(echo "$issue_json" | python3 -c "import json,sys; print(','.join([l['name'] for l in json.load(sys.stdin).get('labels',[])]))")

  # Handle title update
  if [[ -n "$new_title" ]]; then
    gh issue edit "$number" --repo "$REPO" --title "$new_title"
    echo "Updated title to: $new_title"

    # Sync parent task list if issue has a parent
    local parent
    parent=$(parse_metadata_field "$current_body" "parent")
    if [[ -n "$parent" && "$parent" != "null" ]]; then
      sync_parent_task_list "$parent" "$number" "$new_title"
    fi
  fi

  # Handle type update
  if [[ -n "$new_type" ]]; then
    local new_label
    new_label=$(get_type_label "$new_type")

    # Find and remove old type label
    for t in "${VALID_TYPES[@]}"; do
      local old_label="${TYPE_LABELS[$t]}"
      if [[ "$current_labels" == *"$old_label"* ]]; then
        gh issue edit "$number" --repo "$REPO" --remove-label "$old_label" 2>/dev/null || true
      fi
    done

    # Add new type label
    gh issue edit "$number" --repo "$REPO" --add-label "$new_label"
    echo "Updated type to: $new_type"
  fi

  # Handle body update
  if [[ -n "$new_body" ]]; then
    # Extract metadata and tasks using Python (stdin avoids quoting issues)
    local metadata tasks_section

    metadata=$(echo "$current_body" | python3 -c "
import sys
body = sys.stdin.read()
end_marker = '</details>'
end_pos = body.find(end_marker)
if end_pos != -1:
    print(body[:end_pos + len(end_marker)])
else:
    print('')
")

    tasks_section=$(echo "$current_body" | python3 -c "
import sys
body = sys.stdin.read()
tasks_marker = '## Tasks'
tasks_pos = body.find(tasks_marker)
if tasks_pos != -1:
    print(body[tasks_pos:])
else:
    print('')
")

    # Reassemble: metadata + new body + tasks
    local updated_body
    if [[ -n "$tasks_section" ]]; then
      updated_body="${metadata}"$'\n\n'"${new_body}"$'\n\n'"${tasks_section}"
    else
      updated_body="${metadata}"$'\n\n'"${new_body}"
    fi

    gh issue edit "$number" --repo "$REPO" --body "$updated_body"
    echo "Updated body description"
  fi
}

# Sync a child's title in the parent's task list
# Usage: sync_parent_task_list <parent_number> <child_number> <new_title>
sync_parent_task_list() {
  local parent_number="$1"
  local child_number="$2"
  local new_title="$3"

  # Get parent's body
  local parent_body
  parent_body=$(gh issue view "$parent_number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Warning: Could not find parent #$parent_number to sync task list" >&2
    return 0
  }

  # Update the task list entry
  local updated_body
  updated_body=$(update_task_list_title "$parent_body" "$child_number" "$new_title")

  # Save if changed
  if [[ "$updated_body" != "$parent_body" ]]; then
    gh issue edit "$parent_number" --repo "$REPO" --body "$updated_body"
    echo "Synced title to parent #$parent_number task list"
  fi
}

# Manage child issues in task list
# Usage: gbeads children <number> [--add <n,...>] [--remove <n>]
cmd_children() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads children <number> [--add <n,...>] [--remove <n>]" >&2
    exit 1
  fi

  local number="$1"
  shift

  local add_children=""
  local remove_child=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --add)
        add_children="$2"
        shift 2
        ;;
      --remove)
        remove_child="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Get current issue body
  local body
  body=$(gh issue view "$number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # If no flags, list children
  if [[ -z "$add_children" && -z "$remove_child" ]]; then
    list_children "$body"
    return 0
  fi

  local updated_body="$body"

  # Handle add
  if [[ -n "$add_children" ]]; then
    # Split by comma
    IFS=',' read -ra child_numbers <<<"$add_children"
    for child_num in "${child_numbers[@]}"; do
      child_num=$(echo "$child_num" | tr -d ' ')

      # Get child's title
      local child_title
      child_title=$(gh issue view "$child_num" --repo "$REPO" --json title --jq '.title' 2>&1) || {
        echo "Warning: Issue #$child_num not found, skipping" >&2
        continue
      }

      # Update child's metadata to set parent
      local child_body
      child_body=$(gh issue view "$child_num" --repo "$REPO" --json body --jq '.body')
      local updated_child_body
      updated_child_body=$(update_metadata_field "$child_body" "parent" "$number")
      gh issue edit "$child_num" --repo "$REPO" --body "$updated_child_body"

      # Add to task list
      updated_body=$(add_task_list_entry "$updated_body" "$child_num" "$child_title")
      echo "Added #$child_num: $child_title"
    done
  fi

  # Handle remove
  if [[ -n "$remove_child" ]]; then
    # Clear parent in child's metadata
    local child_body
    child_body=$(gh issue view "$remove_child" --repo "$REPO" --json body --jq '.body' 2>/dev/null)
    if [[ -n "$child_body" ]]; then
      local updated_child_body
      updated_child_body=$(update_metadata_field "$child_body" "parent" "null")
      gh issue edit "$remove_child" --repo "$REPO" --body "$updated_child_body"
    fi

    # Remove from task list
    updated_body=$(remove_task_list_entry "$updated_body" "$remove_child")
    echo "Removed #$remove_child from task list"
  fi

  # Save updated parent body
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"
}

# List children from task list
list_children() {
  local body="$1"

  local entries
  entries=$(parse_task_list "$body")

  if [[ -z "$entries" ]]; then
    echo "No children in task list."
    return 0
  fi

  echo "Children:"
  echo "$entries" | while IFS='|' read -r num title checked; do
    local status="[ ]"
    [[ "$checked" == "true" ]] && status="[x]"
    printf "  %s #%-4s %s\n" "$status" "$num" "$title"
  done
}

# Manage issue dependencies
# Usage: gbeads depends <number> [--add <n,m,...>] [--remove <n,m,...>]
cmd_depends() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads depends <number> [--add <n,m,...>] [--remove <n,m,...>]" >&2
    exit 1
  fi

  local number="$1"
  shift

  local add_deps=""
  local remove_deps=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --add)
        add_deps="$2"
        shift 2
        ;;
      --remove)
        remove_deps="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Get current issue
  local issue_data
  issue_data=$(gh issue view "$number" --repo "$REPO" --json number,title,body 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  local title body
  title=$(echo "$issue_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d['title'])")
  body=$(echo "$issue_data" | python3 -c "import sys, json; d=json.load(sys.stdin); print(d['body'])")

  # Parse current depends_on value
  local current_deps
  current_deps=$(parse_metadata_field "$body" "depends_on")
  if [[ -z "$current_deps" ]]; then
    current_deps="[]"
  fi

  # If no flags, display current dependencies
  if [[ -z "$add_deps" && -z "$remove_deps" ]]; then
    echo "Issue #$number: $title"
    # Parse dependencies and fetch titles
    local deps_list
    deps_list=$(echo "$current_deps" | python3 -c "
import sys
import json

deps_str = sys.stdin.read().strip()
try:
    deps = json.loads(deps_str) if deps_str else []
except:
    deps = []

for d in deps:
    print(d)
")
    if [[ -z "$deps_list" ]]; then
      echo "Dependencies: none"
    else
      local dep_display=""
      while IFS= read -r dep_num; do
        local dep_title
        dep_title=$(gh issue view "$dep_num" --repo "$REPO" --json title --jq '.title' 2>/dev/null) || dep_title="(not found)"
        if [[ -n "$dep_display" ]]; then
          dep_display="$dep_display, #$dep_num ($dep_title)"
        else
          dep_display="#$dep_num ($dep_title)"
        fi
      done <<<"$deps_list"
      echo "Dependencies: $dep_display"
    fi
    exit 0
  fi

  # Check for self-dependency before processing
  if [[ -n "$add_deps" ]]; then
    IFS=',' read -ra check_deps <<<"$add_deps"
    for dep_num in "${check_deps[@]}"; do
      dep_num=$(echo "$dep_num" | tr -d ' ')
      if [[ "$dep_num" == "$number" ]]; then
        echo "Error: Issue cannot depend on itself" >&2
        exit 1
      fi
    done
  fi

  # Validate added dependencies exist and collect valid ones
  local valid_adds=""
  if [[ -n "$add_deps" ]]; then
    IFS=',' read -ra dep_numbers <<<"$add_deps"
    for dep_num in "${dep_numbers[@]}"; do
      dep_num=$(echo "$dep_num" | tr -d ' ')
      if [[ -n "$dep_num" ]]; then
        local dep_title
        dep_title=$(gh issue view "$dep_num" --repo "$REPO" --json title --jq '.title' 2>&1) || {
          echo "Warning: Issue #$dep_num not found, skipping" >&2
          continue
        }
        echo "Added dependency: #$dep_num ($dep_title)"
        if [[ -n "$valid_adds" ]]; then
          valid_adds="$valid_adds,$dep_num"
        else
          valid_adds="$dep_num"
        fi
      fi
    done
  fi

  # Recalculate updated_deps with only valid additions
  local updated_deps
  updated_deps=$(echo "$current_deps" | python3 -c "
import sys
import json

current_str = sys.stdin.read().strip()
valid_adds = '$valid_adds'
remove_deps = '$remove_deps'

try:
    deps = json.loads(current_str) if current_str else []
except:
    deps = []

deps_set = set(int(d) for d in deps)

# Only add validated dependencies
if valid_adds:
    for d in valid_adds.split(','):
        d = d.strip()
        if d:
            deps_set.add(int(d))

# Process removals
if remove_deps:
    for d in remove_deps.split(','):
        d = d.strip()
        if d:
            deps_set.discard(int(d))

print(json.dumps(sorted(deps_set)))
")

  # Report removals
  if [[ -n "$remove_deps" ]]; then
    IFS=',' read -ra dep_numbers <<<"$remove_deps"
    for dep_num in "${dep_numbers[@]}"; do
      dep_num=$(echo "$dep_num" | tr -d ' ')
      if [[ -n "$dep_num" ]]; then
        echo "Removed dependency: #$dep_num"
      fi
    done
  fi

  # Update metadata
  local updated_body
  updated_body=$(update_metadata_field "$body" "depends_on" "$updated_deps")

  # Save changes
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"
}

usage() {
  cat <<EOF
gbeads - GitHub issue wrapper for work organization

Agent Workflow:
  gbeads ready              Find unblocked, unclaimed work
  gbeads claim <n> <id>     Claim before starting work
  gbeads close <n>          Mark complete when done

Usage:
  gbeads <command> [options]

Commands:
  init                Create type labels in current repo
  create <type> "title"   Create a typed issue (feature|story|task|bug)
  list                List issues with optional filters
  show <number>       Show issue details
  ready               List available work (unclaimed + unblocked)
  claim <number> <id> Claim an issue for a worker
  unclaim <number>    Release a claimed issue
  update <number>     Update issue title or type
  close <number>      Close an issue
  reopen <number>     Reopen a closed issue
  children <number>   Manage child issues in task list
  depends <number>    Manage issue dependencies

Options:
  -h, --help          Show this help message
  -v, --version       Show version

Examples:
  gbeads init
  gbeads create task "Implement login form"
  gbeads create feature "User authentication" --parent 5
  gbeads list --type task --unclaimed
  gbeads claim 12 agent-001
  gbeads update 12 --title "New title"

EOF
}

version() {
  echo "gbeads version $VERSION"
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -v | --version)
      version
      exit 0
      ;;
    init)
      shift
      cmd_init "$@"
      ;;
    create)
      shift
      cmd_create "$@"
      ;;
    list)
      shift
      cmd_list "$@"
      ;;
    show)
      shift
      cmd_show "$@"
      ;;
    ready)
      shift
      cmd_ready "$@"
      ;;
    claim)
      shift
      cmd_claim "$@"
      ;;
    unclaim)
      shift
      cmd_unclaim "$@"
      ;;
    close)
      shift
      cmd_close "$@"
      ;;
    reopen)
      shift
      cmd_reopen "$@"
      ;;
    update)
      shift
      cmd_update "$@"
      ;;
    children)
      shift
      cmd_children "$@"
      ;;
    depends)
      shift
      cmd_depends "$@"
      ;;
    *)
      echo "Error: Unknown command '$1'" >&2
      echo "Run 'gbeads --help' for usage information." >&2
      exit 1
      ;;
  esac
}

# Only run main if this script is being executed (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
