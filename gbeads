#!/usr/bin/env bash
# gbeads - GitHub issue wrapper for work organization
#
# A lightweight CLI that wraps `gh` to provide work organization
# primitives using GitHub issues with type labels and YAML frontmatter.

set -euo pipefail

readonly VERSION="0.1.0"

# Valid issue types
readonly VALID_TYPES=("feature" "story" "task" "bug")

# Type to label mapping
declare -A TYPE_LABELS=(
  ["feature"]="type: feature"
  ["story"]="type: user story"
  ["task"]="type: task"
  ["bug"]="type: bug"
)

# Get the GitHub repo in owner/repo format from git remote
get_repo() {
  local remote_url
  remote_url=$(git remote get-url origin 2>/dev/null) || {
    echo ""
    return 1
  }

  # Handle SSH format: git@github.com:owner/repo.git
  if [[ "$remote_url" =~ git@github\.com:([^/]+)/(.+)(\.git)?$ ]]; then
    echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    return 0
  fi

  # Handle HTTPS format: https://github.com/owner/repo.git
  if [[ "$remote_url" =~ https://github\.com/([^/]+)/(.+)(\.git)?$ ]]; then
    echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]%.git}"
    return 0
  fi

  echo ""
  return 1
}

# Require that we're in a git repo with a GitHub remote
# Sets REPO variable on success, exits on failure
require_repo() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "Error: Not in a git repository" >&2
    exit 1
  fi

  REPO=$(get_repo)
  if [[ -z "$REPO" ]]; then
    echo "Error: Could not determine GitHub repository from git remote" >&2
    echo "Make sure 'origin' points to a GitHub repository." >&2
    exit 1
  fi

  export REPO
}

# Validate issue type
# Usage: validate_type "type"
validate_type() {
  local type="$1"
  for valid in "${VALID_TYPES[@]}"; do
    if [[ "$type" == "$valid" ]]; then
      return 0
    fi
  done
  echo "Error: Invalid type '$type'" >&2
  echo "Valid types: ${VALID_TYPES[*]}" >&2
  return 1
}

# Get label for type
# Usage: get_type_label "type"
get_type_label() {
  local type="$1"
  echo "${TYPE_LABELS[$type]}"
}

# Create initial frontmatter block
# Usage: create_frontmatter [parent]
create_frontmatter() {
  local parent="${1:-null}"
  cat <<EOF
---
depends_on: []
claimed_by: null
parent: $parent
---
EOF
}

# Parse frontmatter from issue body, returns the value of a field
# Usage: parse_frontmatter_field "body" "field_name"
parse_frontmatter_field() {
  local body="$1"
  local field="$2"

  # Check if body has frontmatter (starts with ---)
  if [[ ! "$body" =~ ^--- ]]; then
    echo ""
    return 0
  fi

  # Extract the frontmatter section
  local frontmatter
  frontmatter=$(echo "$body" | sed -n '/^---$/,/^---$/p' | sed '1d;$d')

  # Extract the field value (grep may not find match, so suppress error)
  echo "$frontmatter" | grep "^${field}:" | sed "s/^${field}: *//" || echo ""
}

# Update a field in the frontmatter, returns the complete updated body
# Usage: update_frontmatter_field "body" "field_name" "new_value"
update_frontmatter_field() {
  local body="$1"
  local field="$2"
  local value="$3"

  # If no frontmatter exists, create it
  if [[ ! "$body" =~ ^--- ]]; then
    local frontmatter
    frontmatter=$(create_frontmatter)
    # Add body content after frontmatter
    body="${frontmatter}"$'\n'"${body}"
  fi

  # Replace the field value in frontmatter
  # This handles both "field: value" and "field: null" formats
  # shellcheck disable=SC2001
  echo "$body" | sed "s/^${field}: .*/${field}: ${value}/"
}

# Extract body content after frontmatter
# Usage: get_body_content "full_body"
get_body_content() {
  local body="$1"

  # If no frontmatter, return as-is
  if [[ ! "$body" =~ ^--- ]]; then
    echo "$body"
    return 0
  fi

  # Skip the frontmatter section (delete from line 1 to second ---)
  # First delete through first ---, then delete through the second ---
  echo "$body" | sed '1d' | sed '1,/^---$/d'
}

# Check if issue body has a task list section
# Usage: has_task_list "body"
has_task_list() {
  local body="$1"
  [[ "$body" =~ "## Tasks" ]]
}

# Add a child to the task list in the body
# Usage: add_task_list_entry "body" "number" "title"
add_task_list_entry() {
  local body="$1"
  local number="$2"
  local title="$3"

  local entry="- [ ] #${number} ${title}"

  if has_task_list "$body"; then
    # Add after ## Tasks heading (POSIX-compatible approach)
    # Note: BSD sed (macOS) and GNU sed have different 'a' command syntax
    # Using awk for cross-platform compatibility
    echo "$body" | awk -v entry="$entry" '/^## Tasks$/{print; print entry; next}1'
  else
    # Add new ## Tasks section at end
    echo "$body"
    echo ""
    echo "## Tasks"
    echo "$entry"
  fi
}

# Remove a child from the task list
# Usage: remove_task_list_entry "body" "number"
remove_task_list_entry() {
  local body="$1"
  local number="$2"

  # Remove line matching "- [ ] #N " or "- [x] #N "
  # Using '|| true' to handle case where all lines are removed (grep -v returns 1)
  echo "$body" | { grep -v "^- \[[ x]\] #${number} " || true; }
}

# Update title in task list entry
# Usage: update_task_list_title "body" "number" "new_title"
update_task_list_title() {
  local body="$1"
  local number="$2"
  local new_title="$3"

  # Replace the title part after #N
  # shellcheck disable=SC2001
  echo "$body" | sed "s/^\(- \[[ x]\] #${number}\) .*/\1 ${new_title}/"
}

# Parse task list entries from body
# Usage: parse_task_list "body"
# Output: "number|title|checked" per line
parse_task_list() {
  local body="$1"

  echo "$body" | { grep "^- \[[ x]\] #[0-9]" || true; } | while read -r line; do
    local checked="false"
    # shellcheck disable=SC2076
    if [[ "$line" =~ "- [x]" ]]; then
      checked="true"
    fi
    local number
    # shellcheck disable=SC2001
    number=$(echo "$line" | sed 's/^- \[[ x]\] #\([0-9]*\).*/\1/')
    local title
    # shellcheck disable=SC2001
    title=$(echo "$line" | sed 's/^- \[[ x]\] #[0-9]* //')
    echo "${number}|${title}|${checked}"
  done
}

# List issues with optional filters
# Usage: gbeads list [--type <type>] [--claimed-by <id>] [--unclaimed] [--state <state>]
cmd_list() {
  require_repo

  local filter_type=""
  local filter_claimed_by=""
  local filter_unclaimed=false
  local filter_state="open"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type)
        filter_type="$2"
        if ! validate_type "$filter_type"; then
          exit 1
        fi
        shift 2
        ;;
      --claimed-by)
        filter_claimed_by="$2"
        shift 2
        ;;
      --unclaimed)
        filter_unclaimed=true
        shift
        ;;
      --state)
        filter_state="$2"
        shift 2
        ;;
      --all)
        filter_state="all"
        shift
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Build label filter
  local label_filter=""
  if [[ -n "$filter_type" ]]; then
    label_filter=$(get_type_label "$filter_type")
  fi

  # Get issues as JSON
  local issues_json
  if [[ -n "$label_filter" ]]; then
    issues_json=$(gh issue list --repo "$REPO" --state "$filter_state" --label "$label_filter" --json number,title,state,body,labels --limit 100)
  else
    issues_json=$(gh issue list --repo "$REPO" --state "$filter_state" --json number,title,state,body,labels --limit 100)
  fi

  # Check if we have any issues
  if [[ -z "$issues_json" ]] || [[ "$issues_json" == "[]" ]]; then
    echo "No issues found."
    return 0
  fi

  # Header
  printf "%-6s %-8s %-12s %s\n" "ID" "TYPE" "CLAIMED" "TITLE"
  printf "%-6s %-8s %-12s %s\n" "------" "--------" "------------" "-----"

  # Parse JSON and display using Python for reliable JSON handling
  # shellcheck disable=SC2016
  echo "$issues_json" | python3 -c "
import json
import sys

data = json.load(sys.stdin)
for issue in data:
    number = issue['number']
    title = issue['title']
    body = issue.get('body', '')
    labels = [l['name'] for l in issue.get('labels', [])]

    # Determine type
    issue_type = 'unknown'
    type_map = {
        'type: feature': 'feature',
        'type: user story': 'story',
        'type: task': 'task',
        'type: bug': 'bug'
    }
    for label in labels:
        if label in type_map:
            issue_type = type_map[label]
            break

    # Parse claimed_by from frontmatter
    claimed_by = '-'
    if body.startswith('---'):
        lines = body.split('\n')
        for line in lines[1:]:
            if line == '---':
                break
            if line.startswith('claimed_by:'):
                val = line.split(':', 1)[1].strip()
                if val and val != 'null':
                    claimed_by = val
                break

    # Apply filters
    filter_claimed = '${filter_claimed_by}'
    filter_unclaimed = '${filter_unclaimed}'

    if filter_claimed and claimed_by != filter_claimed:
        continue
    if filter_unclaimed == 'true' and claimed_by != '-':
        continue

    print(f'#{number:<5} {issue_type:<8} {claimed_by:<12} {title}')
"
}

# Show issue details
# Usage: gbeads show <number>
cmd_show() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads show <number>" >&2
    exit 1
  fi

  local number="$1"

  # Get issue data
  local issue_json
  issue_json=$(gh issue view "$number" --repo "$REPO" --json number,title,state,body,labels 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Parse and display using Python for reliable JSON handling
  # shellcheck disable=SC2016
  echo "$issue_json" | python3 -c "
import json
import sys

issue = json.load(sys.stdin)
number = issue['number']
title = issue['title']
state = issue['state']
body = issue.get('body', '')
labels = [l['name'] for l in issue.get('labels', [])]

# Determine type
issue_type = 'unknown'
type_map = {
    'type: feature': 'feature',
    'type: user story': 'story',
    'type: task': 'task',
    'type: bug': 'bug'
}
for label in labels:
    if label in type_map:
        issue_type = type_map[label]
        break

# Parse frontmatter
depends_on = '[]'
claimed_by = 'null'
parent = 'null'
body_content = body

if body.startswith('---'):
    lines = body.split('\n')
    frontmatter_end = -1
    for i, line in enumerate(lines[1:], 1):
        if line == '---':
            frontmatter_end = i
            break
        if line.startswith('depends_on:'):
            depends_on = line.split(':', 1)[1].strip()
        elif line.startswith('claimed_by:'):
            claimed_by = line.split(':', 1)[1].strip()
        elif line.startswith('parent:'):
            parent = line.split(':', 1)[1].strip()

    if frontmatter_end > 0:
        body_content = '\n'.join(lines[frontmatter_end + 1:]).strip()

print(f'Issue #{number}: {title}')
print(f'Type:       {issue_type}')
print(f'State:      {state}')
print(f'Claimed by: {claimed_by}')
print(f'Parent:     {parent}')
print(f'Depends on: {depends_on}')
if body_content:
    print()
    print('Description:')
    print(body_content)
"
}

# Initialize gbeads labels in the repository
cmd_init() {
  require_repo

  echo "Initializing gbeads labels in $REPO..."

  local created=0
  local exists=0

  for type in "${VALID_TYPES[@]}"; do
    local label="${TYPE_LABELS[$type]}"
    if gh label create "$label" --repo "$REPO" --description "gbeads: $type" 2>/dev/null; then
      echo "  Created: $label"
      created=$((created + 1))
    else
      echo "  Exists: $label"
      exists=$((exists + 1))
    fi
  done

  echo "Done. Created $created labels, $exists already existed."
}

# Create a new issue
# Usage: gbeads create <type> "title" [--parent <n>]
cmd_create() {
  require_repo

  if [[ $# -lt 2 ]]; then
    echo "Usage: gbeads create <type> \"title\" [--parent <n>]" >&2
    exit 1
  fi

  local type="$1"
  local title="$2"
  shift 2

  # Validate type
  if ! validate_type "$type"; then
    exit 1
  fi

  # Parse optional flags
  local parent=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --parent)
        parent="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  # Create frontmatter
  local body
  if [[ -n "$parent" ]]; then
    body=$(create_frontmatter "$parent")
  else
    body=$(create_frontmatter)
  fi

  # Get the label for this type
  local label
  label=$(get_type_label "$type")

  # Create the issue
  local output
  output=$(gh issue create --repo "$REPO" --title "$title" --body "$body" --label "$label")

  # Extract issue number from output URL
  local number
  number=$(echo "$output" | grep -o '[0-9]*$')

  echo "Created $type #$number: $title"

  # If parent specified, update parent's task list
  if [[ -n "$parent" ]]; then
    local parent_body
    parent_body=$(gh issue view "$parent" --repo "$REPO" --json body --jq '.body')

    local updated_body
    updated_body=$(add_task_list_entry "$parent_body" "$number" "$title")

    gh issue edit "$parent" --repo "$REPO" --body "$updated_body"
    echo "Added to parent #$parent task list"
  fi
}

# Claim an issue for a worker
# Usage: gbeads claim <number> <worker-id>
cmd_claim() {
  require_repo

  if [[ $# -lt 2 ]]; then
    echo "Usage: gbeads claim <number> <worker-id>" >&2
    exit 1
  fi

  local number="$1"
  local worker_id="$2"

  # Get current issue body
  local body
  body=$(gh issue view "$number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Check if already claimed
  local current_claimed
  current_claimed=$(parse_frontmatter_field "$body" "claimed_by")
  if [[ -n "$current_claimed" && "$current_claimed" != "null" ]]; then
    echo "Error: Issue #$number is already claimed by $current_claimed" >&2
    exit 1
  fi

  # Update claimed_by in frontmatter
  local updated_body
  updated_body=$(update_frontmatter_field "$body" "claimed_by" "$worker_id")

  # Save updated body
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"

  echo "Claimed issue #$number for $worker_id"
}

# Release a claimed issue
# Usage: gbeads unclaim <number>
cmd_unclaim() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads unclaim <number>" >&2
    exit 1
  fi

  local number="$1"

  # Get current issue body
  local body
  body=$(gh issue view "$number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  # Check if actually claimed
  local current_claimed
  current_claimed=$(parse_frontmatter_field "$body" "claimed_by")
  if [[ -z "$current_claimed" || "$current_claimed" == "null" ]]; then
    echo "Issue #$number is not claimed" >&2
    exit 0
  fi

  # Update claimed_by to null
  local updated_body
  updated_body=$(update_frontmatter_field "$body" "claimed_by" "null")

  # Save updated body
  gh issue edit "$number" --repo "$REPO" --body "$updated_body"

  echo "Released claim on issue #$number (was: $current_claimed)"
}

# Close an issue
# Usage: gbeads close <number>
cmd_close() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads close <number>" >&2
    exit 1
  fi

  local number="$1"

  gh issue close "$number" --repo "$REPO" || {
    echo "Error: Failed to close issue #$number" >&2
    exit 1
  }

  echo "Closed issue #$number"
}

# Reopen a closed issue
# Usage: gbeads reopen <number>
cmd_reopen() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads reopen <number>" >&2
    exit 1
  fi

  local number="$1"

  gh issue reopen "$number" --repo "$REPO" || {
    echo "Error: Failed to reopen issue #$number" >&2
    exit 1
  }

  echo "Reopened issue #$number"
}

# Update an issue
# Usage: gbeads update <number> [--title "new title"] [--type <type>]
cmd_update() {
  require_repo

  if [[ $# -lt 1 ]]; then
    echo "Usage: gbeads update <number> [--title \"new title\"] [--type <type>]" >&2
    exit 1
  fi

  local number="$1"
  shift

  local new_title=""
  local new_type=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        new_title="$2"
        shift 2
        ;;
      --type)
        new_type="$2"
        if ! validate_type "$new_type"; then
          exit 1
        fi
        shift 2
        ;;
      *)
        echo "Error: Unknown option '$1'" >&2
        exit 1
        ;;
    esac
  done

  if [[ -z "$new_title" && -z "$new_type" ]]; then
    echo "Error: Must specify --title or --type" >&2
    exit 1
  fi

  # Get current issue data
  local issue_json
  issue_json=$(gh issue view "$number" --repo "$REPO" --json title,body,labels 2>&1) || {
    echo "Error: Issue #$number not found" >&2
    exit 1
  }

  local current_title current_body current_labels
  current_title=$(echo "$issue_json" | python3 -c "import json,sys; print(json.load(sys.stdin)['title'])")
  current_body=$(echo "$issue_json" | python3 -c "import json,sys; print(json.load(sys.stdin).get('body',''))")
  current_labels=$(echo "$issue_json" | python3 -c "import json,sys; print(','.join([l['name'] for l in json.load(sys.stdin).get('labels',[])]))")

  # Handle title update
  if [[ -n "$new_title" ]]; then
    gh issue edit "$number" --repo "$REPO" --title "$new_title"
    echo "Updated title to: $new_title"

    # Sync parent task list if issue has a parent
    local parent
    parent=$(parse_frontmatter_field "$current_body" "parent")
    if [[ -n "$parent" && "$parent" != "null" ]]; then
      sync_parent_task_list "$parent" "$number" "$new_title"
    fi
  fi

  # Handle type update
  if [[ -n "$new_type" ]]; then
    local new_label
    new_label=$(get_type_label "$new_type")

    # Find and remove old type label
    for t in "${VALID_TYPES[@]}"; do
      local old_label="${TYPE_LABELS[$t]}"
      if [[ "$current_labels" == *"$old_label"* ]]; then
        gh issue edit "$number" --repo "$REPO" --remove-label "$old_label" 2>/dev/null || true
      fi
    done

    # Add new type label
    gh issue edit "$number" --repo "$REPO" --add-label "$new_label"
    echo "Updated type to: $new_type"
  fi
}

# Sync a child's title in the parent's task list
# Usage: sync_parent_task_list <parent_number> <child_number> <new_title>
sync_parent_task_list() {
  local parent_number="$1"
  local child_number="$2"
  local new_title="$3"

  # Get parent's body
  local parent_body
  parent_body=$(gh issue view "$parent_number" --repo "$REPO" --json body --jq '.body' 2>&1) || {
    echo "Warning: Could not find parent #$parent_number to sync task list" >&2
    return 0
  }

  # Update the task list entry
  local updated_body
  updated_body=$(update_task_list_title "$parent_body" "$child_number" "$new_title")

  # Save if changed
  if [[ "$updated_body" != "$parent_body" ]]; then
    gh issue edit "$parent_number" --repo "$REPO" --body "$updated_body"
    echo "Synced title to parent #$parent_number task list"
  fi
}

usage() {
  cat <<EOF
gbeads - GitHub issue wrapper for work organization

Usage:
  gbeads <command> [options]

Commands:
  init                Create type labels in current repo
  create <type> "title"   Create a typed issue (feature|story|task|bug)
  list                List issues with optional filters
  show <number>       Show issue details
  claim <number> <id> Claim an issue for a worker
  unclaim <number>    Release a claimed issue
  update <number>     Update issue title or type
  close <number>      Close an issue
  reopen <number>     Reopen a closed issue
  children <number>   Manage child issues in task list

Options:
  -h, --help          Show this help message
  -v, --version       Show version

Examples:
  gbeads init
  gbeads create task "Implement login form"
  gbeads create feature "User authentication" --parent 5
  gbeads list --type task --unclaimed
  gbeads claim 12 agent-001
  gbeads update 12 --title "New title"

EOF
}

version() {
  echo "gbeads version $VERSION"
}

main() {
  if [[ $# -eq 0 ]]; then
    usage
    exit 0
  fi

  case "$1" in
    -h | --help)
      usage
      exit 0
      ;;
    -v | --version)
      version
      exit 0
      ;;
    init)
      shift
      cmd_init "$@"
      ;;
    create)
      shift
      cmd_create "$@"
      ;;
    list)
      shift
      cmd_list "$@"
      ;;
    show)
      shift
      cmd_show "$@"
      ;;
    claim)
      shift
      cmd_claim "$@"
      ;;
    unclaim)
      shift
      cmd_unclaim "$@"
      ;;
    close)
      shift
      cmd_close "$@"
      ;;
    reopen)
      shift
      cmd_reopen "$@"
      ;;
    update)
      shift
      cmd_update "$@"
      ;;
    children)
      echo "Error: Command '$1' not yet implemented" >&2
      exit 1
      ;;
    *)
      echo "Error: Unknown command '$1'" >&2
      echo "Run 'gbeads --help' for usage information." >&2
      exit 1
      ;;
  esac
}

# Only run main if this script is being executed (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
